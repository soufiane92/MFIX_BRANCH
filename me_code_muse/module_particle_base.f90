MODULE M_PARTICLE_BASE
  IMPLICIT NONE
  TYPE PARTICLE
     REAL(KIND=8) :: X=0,Y=0
     REAL(KIND=8) :: U=0,V=0
     REAL(KIND=8) :: FX=0,FY=0
     REAL(KIND=8) :: M=1
     REAL(KIND=8) :: RHO=1
     REAL(KIND=8) :: R=1
     
     INTEGER BC_X_FLAG 
     INTEGER BC_Y_FLAG 

     REAL(KIND=8) :: DATA
     REAL(KIND=8) :: RX=0,RY=0
  END TYPE PARTICLE

CONTAINS
  SUBROUTINE PARTICLE_COPY(P_OLD,P_NEW)
    IMPLICIT NONE
    TYPE(PARTICLE)::P_NEW,P_OLD
    REAL(KIND=8) :: FX,FY,DT

    !> VELOCITY UPDATE
    P_OLD%U = P_NEW%U 
    P_OLD%V = P_NEW%V
    P_OLD%X = P_NEW%X 
    P_OLD%Y = P_NEW%Y

    P_OLD%FX = P_NEW%FX 
    P_OLD%FY = P_NEW%FY

    P_OLD%M = P_NEW%M
    P_OLD%R = P_NEW%R
    P_OLD%RHO = P_NEW%RHO

    !PRINT*,"PARTICLE COPY DONE"

  END SUBROUTINE PARTICLE_COPY

  ! SUBROUTINE PARTICLE_ZERO(P)
  !   IMPLICIT NONE
  !   TYPE(PARTICLE)::P
  !   !> VELOCITY UPDATE
  !   P%U = 0.0
  !   P%V = 0.0
  !   P%X = 0.0
  !   P%Y = 0.0
  !   P%FX = 0.0
  !   P%FY = 0.0
  ! END SUBROUTINE PARTICLE_ZERO
  
  ! SUBROUTINE MAKE_A_TIME_STEP(P_OLD,P_NEW,DT,FX,FY)
  !   IMPLICIT NONE
  !   TYPE(PARTICLE)::P_NEW,P_OLD
  !   REAL(KIND=8) :: FX,FY,DT

  !   !> VELOCITY UPDATE
  !   P_NEW%U = P_OLD%U + DT*P_OLD%FX/P_OLD%M
  !   P_NEW%V = P_OLD%V + DT*P_OLD%FY/P_OLD%M
  !   !> DISPLACEMENT UPDATE
  !   P_NEW%X = P_OLD%X + DT*P_NEW%U
  !   P_NEW%Y = P_OLD%Y + DT*P_NEW%V
    
  ! END SUBROUTINE MAKE_A_TIME_STEP

  SUBROUTINE EXPORT(FILENAME,PLIST,N,IT)
    IMPLICIT NONE
    CHARACTER(LEN=*) :: FILENAME
    TYPE(PARTICLE),DIMENSION(N) :: PLIST
    INTEGER,OPTIONAL :: IT
    INTEGER :: N,K
    
    
    IF (PRESENT(IT)) THEN
       OPEN(UNIT=24,FILE=TRIM(FILENAME),ACCESS = 'APPEND',STATUS='OLD')
       WRITE(24,'("ZONE T=""",I5 ,""" ")'),IT
    ELSE
       OPEN(UNIT=24,FILE=TRIM(FILENAME))
       WRITE(24,'("ZONE T=""",I5 ,""" ")'),0
    END IF
    DO K=1,N
       WRITE(24,'(10(E15.8,1X))')PLIST(K)%X,PLIST(K)%Y,PLIST(K)%U&
            &,PLIST(K)%V,PLIST(K)%R,PLIST(K)%RX,PLIST(K)%RY
    END DO
    CLOSE(24)
    
  END SUBROUTINE EXPORT

  SUBROUTINE UPDATE_CONTACT_LIST(LIST_OF_PARTICLES,NB_PARTICLES,LIST_OF_CONTACTS,NB_CONTACTS,DISTANCE_CONTACT)
    IMPLICIT NONE
    
    INTEGER :: NB_PARTICLES,NB_CONTACTS
    TYPE(PARTICLE),DIMENSION(:),ALLOCATABLE::LIST_OF_PARTICLES
    INTEGER ,DIMENSION(:,:),ALLOCATABLE:: LIST_OF_CONTACTS
    REAL(KIND=8) :: DISTANCE_CONTACT

    INTEGER :: P,Q
    REAL(KIND=8) :: D2,DC2
    REAL(KIND=8) :: XP,XQ
    REAL(KIND=8) :: YP,YQ
    REAL(KIND=8) :: RQ,RP
    
    REAL(KIND=8) :: XC,YC
    REAL(KIND=8) :: NX,NY
    REAL(KIND=8) :: DX,DY
    REAL(KIND=8) :: XCP,XCQ
    REAL(KIND=8) :: YCP,YCQ
    REAL(KIND=8) :: C_DOT_N,CP_DOT_N,CQ_DOT_N,G
    
    DC2 = (0.1*DISTANCE_CONTACT)**2
    !PRINT*,DC2
    
    LIST_OF_PARTICLES(1:NB_PARTICLES)%DATA=0
    NB_CONTACTS=0
    DO P = 1 , NB_PARTICLES-4
       DO Q = P+1 , NB_PARTICLES
          
          DX = (LIST_OF_PARTICLES(Q)%X-LIST_OF_PARTICLES(P)%X)
          DY = (LIST_OF_PARTICLES(Q)%Y-LIST_OF_PARTICLES(P)%Y)

          G = SQRT(DX**2+DY**2)-(LIST_OF_PARTICLES(P)%R+LIST_OF_PARTICLES(Q)%R)
          IF ( G<0 ) THEN
             NB_CONTACTS = NB_CONTACTS + 1
             LIST_OF_CONTACTS(NB_CONTACTS,1) = P
             LIST_OF_CONTACTS(NB_CONTACTS,2) = Q
             LIST_OF_PARTICLES(P)%DATA =  P
          END IF
          
          
          
       END DO
       
    END DO
    
  END SUBROUTINE UPDATE_CONTACT_LIST
  
  SUBROUTINE GET_DISTANCE(LIST_OF_PARTICLES,NB_PARTICLES,LIST_OF_CONTACTS,NB_CONTACTS, ACTIVE,DMAX)
    IMPLICIT NONE
    INTEGER :: NB_PARTICLES,NB_CONTACTS
    TYPE(PARTICLE),DIMENSION(:),ALLOCATABLE::LIST_OF_PARTICLES
    INTEGER ,DIMENSION(:,:),ALLOCATABLE:: LIST_OF_CONTACTS
    LOGICAL ,DIMENSION(:) , ALLOCATABLE :: ACTIVE
    REAL(KIND=8) :: DMAX
    

    INTEGER :: C,P,Q
    REAL(KIND=8) :: D2,DC2
    REAL(KIND=8) :: XP,XQ
    REAL(KIND=8) :: YP,YQ
    REAL(KIND=8) :: RQ,RP

    REAL(KIND=8) :: XC,YC
    REAL(KIND=8) :: NX,NY
    REAL(KIND=8) :: DX,DY
    REAL(KIND=8) :: XCP,XCQ
    REAL(KIND=8) :: YCP,YCQ
    
   
    DMAX=0
    DO C = 1 , NB_CONTACTS

       IF (ACTIVE(C)) THEN
          P = LIST_OF_CONTACTS(C,1)
          Q = LIST_OF_CONTACTS(C,2)
          
          !>
          DX = (LIST_OF_PARTICLES(Q)%X-LIST_OF_PARTICLES(P)%X)
          DY = (LIST_OF_PARTICLES(Q)%Y-LIST_OF_PARTICLES(P)%Y)
          
          NX = DX/SQRT(DX**2+DY**2)
          NY = DY/SQRT(DX**2+DY**2)
          
          XCP= (LIST_OF_PARTICLES(P)%X + LIST_OF_PARTICLES(P)%R*NX)
          YCP= (LIST_OF_PARTICLES(P)%Y + LIST_OF_PARTICLES(P)%R*NY)
          
          XCQ= (LIST_OF_PARTICLES(Q)%X - LIST_OF_PARTICLES(Q)%R*NX)
          YCQ= (LIST_OF_PARTICLES(Q)%Y - LIST_OF_PARTICLES(Q)%R*NY)
          
          DMAX = SQRT((XCQ-XCP)**2+(YCQ-YCP)**2)
          DMAX = MAX(0D0,DMAX)
       END IF
       
    END DO
    
    
  END SUBROUTINE GET_DISTANCE
   

  SUBROUTINE EXPORT_REACTION(PARTICLES,NB_P,CONTACT_PARTICLES,NB_C,PN)
    IMPLICIT NONE
    INTEGER :: NB_P,NB_C
    TYPE(PARTICLE),DIMENSION(:),ALLOCATABLE::PARTICLES
    INTEGER ,DIMENSION(:,:),ALLOCATABLE:: CONTACT_PARTICLES
!    LOGICAL ,DIMENSION(:) , ALLOCATABLE :: ACTIVE
    REAL(KIND=8) ,DIMENSION(:) , ALLOCATABLE :: PN
    REAL(KIND=8) :: DMAX
    

    INTEGER :: C,P,Q
    REAL(KIND=8) :: NX,NY
    REAL(KIND=8) :: DX,DY
    
    DMAX=0
    PARTICLES(:)%RX=0
    PARTICLES(:)%RY=0
    DO C = 1 , NB_C
       P = CONTACT_PARTICLES(C,1)
       Q = CONTACT_PARTICLES(C,2)
       !>
       DX = (PARTICLES(Q)%X-PARTICLES(P)%X)
       DY = (PARTICLES(Q)%Y-PARTICLES(P)%Y)
       
       NX = DX/SQRT(DX**2+DY**2)
       NY = DY/SQRT(DX**2+DY**2)

!       PARTICLES(P)%RX = PARTICLES(P)%RX - PN(C)*NX
!       PARTICLES(P)%RY = PARTICLES(P)%RY - PN(C)*NY 
       PARTICLES(P)%RX = PARTICLES(P)%RX + ABS(PN(C))
       PARTICLES(Q)%RY = 0
       
    END DO
    
    
  END SUBROUTINE EXPORT_REACTION

  


   SUBROUTINE GET_LOCAL_VEL(PI,PJ,PTI,PTJ,UN,UT)
     IMPLICIT NONE
     TYPE(PARTICLE) :: PI,PJ   !> PARTICULE DONT ON 
     TYPE(PARTICLE) :: PTI,PTJ !> POUR LE REPERE LOCAL
     REAL(KIND=8)   :: UN,UT   !> VITESSE RELATIVE TANGENTIELLE
 
    REAL(KIND=8) :: DU,DV
    REAL(KIND=8) :: DX,DY
    REAL(KIND=8) :: NX,NY
    REAL(KIND=8) :: TX,TY
    

    !> VITESSE RELATIVE REPERE GLOBAL
    DU = PJ%U - PI%U
    DV = PJ%V - PI%V

    !> VITESSE RELATIVE REPERE LOCAL

    DX = PTJ%X - PTI%X
    DY = PTJ%Y - PTI%Y
    !> N(NX,NY) NORMALE A PARTIR DE PTJ ET PTI 
    NX = DX/(SQRT(DX**2+DY**2))
    NY = DY/(SQRT(DX**2+DY**2))
    !> TAU(TX,TY) TQ (N VEC TAU) > 0 EN 2D 
    TX = -NY 
    TY = +NX
    
    !> PROJECTION SUR LA TENGE
    UN = (DU*NX+DV*NY)
    UT = DU*TX+DV*TY
    
  END SUBROUTINE GET_LOCAL_VEL
  
  
END MODULE M_PARTICLE_BASE

